import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { TicketRepository } from 'src/tickets/domain/repositories/ticket.repository';
import { AnswerRepository } from 'src/tickets/domain/repositories/answer.repository';
import { Answer } from 'src/tickets/domain/entities/answer.entity';
import { UUID } from 'src/shared/value-objects/uuid.vo';
import { TicketStatusEnum } from 'src/tickets/domain/value-objects/ticket-status.vo';

interface AnswerTicketUseCaseInput {
  ticketId: string;
  content: string;
  answeredBy?: string; // User ID who is answering
}

interface AnswerTicketUseCaseOutput {
  ticketId: string;
  answerId: string;
  content: string;
  answeredAt: Date;
}

@Injectable()
export class AnswerTicketUseCase {
  constructor(
    private readonly ticketRepository: TicketRepository,
    private readonly answerRepository: AnswerRepository,
  ) {}

  async execute({
    ticketId,
    content,
    answeredBy,
  }: AnswerTicketUseCaseInput): Promise<AnswerTicketUseCaseOutput> {
    // Find the ticket
    const ticket = await this.ticketRepository.findById(ticketId);

    if (!ticket) {
      throw new NotFoundException('Ticket not found');
    }

    // Check if ticket is auto-generated (only non-autogenerated tickets can be answered)
    if (ticket.isAutoGenerated) {
      throw new ForbiddenException('Cannot answer auto-generated tickets');
    }

    // Check if ticket already has an answer
    const existingAnswer = await this.answerRepository.findByTicketId(
      UUID.create(ticketId),
    );

    if (existingAnswer) {
      throw new ForbiddenException('Ticket already has an answer');
    }

    // Create the answer
    const answer = Answer.create({
      ticketId,
      content,
    });

    // Save the answer
    const savedAnswer = await this.answerRepository.save(answer);

    // Update ticket status to answered
    ticket.status = TicketStatusEnum.RESOLVED;
    await this.ticketRepository.save(ticket);

    // Add answer to ticket entity
    ticket.answer = savedAnswer;

    return {
      ticketId: ticketId,
      answerId: savedAnswer.id.toString(),
      content: savedAnswer.content,
      answeredAt: savedAnswer.createdAt,
    };
  }
}
