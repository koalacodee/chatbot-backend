import {
  Injectable,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { TicketRepository } from 'src/tickets/domain/repositories/ticket.repository';
import { AnswerRepository } from 'src/tickets/domain/repositories/answer.repository';
import { Answer } from 'src/tickets/domain/entities/answer.entity';
import { UUID } from 'src/shared/value-objects/uuid.vo';
import { TicketStatusEnum } from 'src/tickets/domain/value-objects/ticket-status.vo';
import { FilesService } from 'src/files/domain/services/files.service';

interface AnswerTicketUseCaseInput {
  ticketId: string;
  content: string;
  answeredBy?: string; // User ID who is answering
  attach?: boolean;
}

interface AnswerTicketUseCaseOutput {
  ticketId: string;
  answerId: string;
  content: string;
  answeredAt: Date;
  uploadKey?: string;
}

@Injectable()
export class AnswerTicketUseCase {
  constructor(
    private readonly ticketRepository: TicketRepository,
    private readonly answerRepository: AnswerRepository,
    private readonly filesService: FilesService,
  ) {}

  async execute({
    ticketId,
    content,
    answeredBy,
    attach,
  }: AnswerTicketUseCaseInput): Promise<AnswerTicketUseCaseOutput> {
    // Find the ticket
    const ticket = await this.ticketRepository.findById(ticketId);

    if (!ticket) {
      throw new NotFoundException({
        details: [{ field: 'ticketId', message: 'Ticket not found' }],
      });
    }

    // Check if ticket is auto-generated (only non-autogenerated tickets can be answered)
    if (ticket.isAutoGenerated) {
      throw new ForbiddenException({
        details: [
          { field: 'ticket', message: 'Cannot answer auto-generated tickets' },
        ],
      });
    }

    // Check if ticket already has an answer
    const existingAnswer = await this.answerRepository.findByTicketId(
      UUID.create(ticketId),
    );

    if (existingAnswer) {
      throw new ForbiddenException({
        details: [{ field: 'ticket', message: 'Ticket already has an answer' }],
      });
    }

    // Create the answer
    const answer = Answer.create({
      ticketId,
      content,
    });

    // Save the answer
    const savedAnswer = await this.answerRepository.save(answer);

    // Update ticket status to answered
    ticket.status = TicketStatusEnum.CLOSED;
    await this.ticketRepository.save(ticket);

    // Add answer to ticket entity
    ticket.answer = savedAnswer;

    const uploadKey = attach
      ? await this.filesService.genUploadKey(
          savedAnswer.id.toString(),
          answeredBy,
        )
      : undefined;

    return {
      ticketId: ticketId,
      answerId: savedAnswer.id.toString(),
      content: savedAnswer.content,
      answeredAt: savedAnswer.createdAt,
      uploadKey,
    };
  }
}
