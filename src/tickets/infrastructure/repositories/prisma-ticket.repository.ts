import { Injectable } from '@nestjs/common';
import { PrismaService } from '../../../common/prisma/prisma.service';
import { TicketRepository } from '../../domain/repositories/ticket.repository';
import { Ticket } from '../../domain/entities/ticket.entity';
import { Department } from 'src/department/domain/entities/department.entity';
import { TicketStatusEnum } from 'src/tickets/domain/value-objects/ticket-status.vo';

@Injectable()
export class PrismaTicketRepository extends TicketRepository {
  constructor(private readonly prisma: PrismaService) {
    super();
  }

  private async toDomain(ticket: any): Promise<Ticket> {
    return Ticket.create({
      id: ticket.id,
      guest: ticket.guest,
      question: ticket.question,
      department: Department.create(ticket.department),
      ticketCode: ticket.ticketCode,
      pointId: ticket.pointId,
    });
  }

  async save(ticket: Ticket): Promise<Ticket> {
    const data = {
      id: ticket.id.toString(),
      guest: { connect: { id: ticket.guest.id.toString() } },
      question: ticket.question,
      department: { connect: { id: ticket.department.id.toString() } },
      pointId: ticket.pointId?.toString(),
      ticketCode: ticket.ticketCode.value,
      status: TicketStatusEnum[ticket.status.value],
    };

    const upsert = await this.prisma.ticket.upsert({
      where: { id: data.id },
      update: { ...data, status: TicketStatusEnum[ticket.status.value] },
      create: data,
      include: {
        guest: true,
        department: true,
      },
    });

    return await this.toDomain(upsert);
  }

  async saveMany(tickets: Ticket[]): Promise<Ticket[]> {
    const data = tickets.map((ticket) => ({
      id: ticket.id.toString(),
      guest: { connect: { id: ticket.guest.id.toString() } },
      question: ticket.question,
      department: { connect: { id: ticket.department.id.toString() } },
      pointId: ticket.pointId,
      ticketCode: ticket.ticketCode.value,
      status: TicketStatusEnum[ticket.status.value],
    }));

    // Use transaction to ensure all operations succeed or fail together
    const result = await this.prisma.$transaction(async (tx) => {
      const upsertTickets = [];
      for (const ticketData of data) {
        const upsert = await (tx as any).ticket.upsert({
          where: { id: ticketData.id },
          update: ticketData,
          create: ticketData,
          include: {
            guest: true,
            department: true,
          },
        });
        upsertTickets.push(upsert);
      }
      return upsertTickets;
    });

    return Promise.all(result.map((ticket) => this.toDomain(ticket)));
  }

  async findById(id: string): Promise<Ticket | null> {
    const ticket = await (this.prisma as any).ticket.findUnique({
      where: { id },
      include: {
        guest: true,
        department: true,
      },
    });

    return ticket ? await this.toDomain(ticket) : null;
  }

  async findByIds(ids: string[]): Promise<Ticket[]> {
    const tickets = await (this.prisma as any).ticket.findMany({
      where: { id: { in: ids } },
      include: {
        guest: true,
        department: true,
      },
    });

    return Promise.all(tickets.map((ticket) => this.toDomain(ticket)));
  }

  async removeById(id: string): Promise<Ticket | null> {
    const ticket = await this.findById(id);
    if (!ticket) return null;

    await (this.prisma as any).ticket.delete({ where: { id } });
    return ticket;
  }

  async removeByIds(ids: string[]): Promise<Ticket[]> {
    const tickets = await this.findByIds(ids);
    if (tickets.length === 0) return [];

    await (this.prisma as any).ticket.deleteMany({
      where: { id: { in: ids } },
    });

    return tickets;
  }

  async count(): Promise<number> {
    return (this.prisma as any).ticket.count();
  }

  async exists(id: string): Promise<boolean> {
    const count = await (this.prisma as any).ticket.count({ where: { id } });
    return count > 0;
  }

  async findAll(offset?: number, limit?: number): Promise<Ticket[]> {
    const tickets = await (this.prisma as any).ticket.findMany({
      skip: offset,
      take: limit,
      include: {
        guest: true,
        department: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return Promise.all(tickets.map((ticket) => this.toDomain(ticket)));
  }

  async findPendingTickets(isAutoGenerated: boolean = true): Promise<Ticket[]> {
    const tickets = await this.prisma.ticket.findMany({
      where: {
        status: TicketStatusEnum.PENDING,
        isAutoGenerated,
      },
      include: {
        guest: true,
        department: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    return Promise.all(tickets.map((ticket: any) => this.toDomain(ticket)));
  }

  async findByPointIds(pointIds: string[]): Promise<Ticket[]> {
    const tickets = await (this.prisma as any).ticket.findMany({
      where: { pointId: { in: pointIds } },
      include: {
        guest: true,
        department: true,
      },
    });

    return Promise.all(tickets.map((ticket: any) => this.toDomain(ticket)));
  }

  async findByTicketCode(code: string): Promise<Ticket> {
    return this.prisma.ticket
      .findUnique({
        where: { ticketCode: code },
        include: { guest: true, department: true },
      })
      .then((ticket) => (ticket ? this.toDomain(ticket) : null));
  }
}
